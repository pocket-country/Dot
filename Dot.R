# Dot.R - A "toy" demo recursive descent parser for expressions hand crafted in the R programming language!
#ToDo:
# - (OK) implement + operator (i.e. pull from input not fixed)
#        -- this sets the stage for general set of operators
# - implement () for grouping ... this will really show of recursion vs regex
# - Figure out operator precedence -- there is some default precedence built in - so can talk about it at prezzie.  
#   (May have to do a term/factor thing to show off how () affect precedence)
# - error handling
# - - invalid characters
# - - incorrect syntax
# - evaluate using traverse function
# - token types: 
#     -- (OK) operator 
#     -- (OKish) numeric - have my lame ass Digit
#     -- literal (whut for strings)?
#     -- oh yea and parens & other syntax elements ... 
# - actual multi-digit numbers, 0 + pos integers (overflow?)
# - text panel with grammar & explanation
# - open in 'full screen' size ....
# - L8ter make a package
# - plot display token type/value rather than node ID
# - figure out github push to facilitating working 'at home'
#
library(shiny)
library(data.tree)
library(DiagrammeR) #graph viz HTML widget to render tree data
library(igraph)     #Not sure if needed - for node plotting functions, such as SetNodeStyle   
## Lexing and parsing functions should come in automatically from Parse.R in ./R folder 
## according to anonymous sources on the interweb.  We shall see.

## Magic Function to format nodes, hard won knowledge: tast$Do(function(node) SetNodeStyle(node, label = node$sval, shape = "square"))

ui <- fluidPage(
  titlePanel(
    h4("===   Dot   ===", style = "text-align:center")
  ),
  tags$head(
      tags$style(HTML("hr {border-top: 1px solid #000000;}"))
  ),
  sidebarLayout(
    sidebarPanel(
      # so this "stuff" will appear in the sidebar - but because the app doesn't open in full screen mode
      # (or even close) it just squishes it up to the top, looks odd.
      "Settings",
      textInput("textin","Enter expression text here"),
      #checkboxInput("isfile","Use input as filename"),  ## currently unused
      hr(),
      p("Dot functionality - quit here or use buttons in processing sequence section below! "),
      actionButton("exitbutton","Quit"),
      hr(),
      HTML(r"[
          <p>DOT Grammer</p>
          <ul>
          <li> first rule here </li>
          <li> second rule here </li>
          </ul>
        ]")
    ),
    mainPanel(
      h3("Processing Sequence"),
      
      #h2("Raw Input"),
      #textOutput("echo_out"),
      
      h2("Tokens"),
      actionButton("lexit","Run Lexer"),
      tableOutput("lex_out"),
      
      h2("AST"),
      actionButton("parseit","Run Parser"),
      grVizOutput("ast")
      
    )
  )
)

server <- function(input, output) {
  
  #echo raw input
  #output$echo_out <- renderText({
  #  req(input$textin)
  #  paste(":", input$textin)
  #})
  # this is our stop button
  observeEvent(input$exitbutton, {stopApp(0)})
  
  # make a reactive element tt holding tokens table when lexer button is clicked
  tt <- eventReactive(input$lexit, {
    # lexer takes text input and generates token table tt
    lexer(input$textin)
  })
  # and render it
  output$lex_out <- renderTable({
    tt()
  })
  
  # same strategy to generate and render AST
  rn <- eventReactive(input$parseit, {
    dot_parse(tt())
    #as.data.frame(matrix(runif(n=100),nrow=50))
  })
  output$ast <- renderGrViz({
    #rn()
    plot(rn())
  })
}

#run the app
shinyApp(ui = ui, server = server)